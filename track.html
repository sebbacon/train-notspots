<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Route Coverage Logger (GPS-silence detection)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:12px}
  button{margin-right:6px;margin-top:6px}
  pre{white-space:pre-wrap;background:#f6f6f8;padding:8px;border-radius:6px}
  #mapwrap{margin-top:12px}
  #map{width:100%;height:320px;border:1px solid #ddd;border-radius:6px;background:#fafafa}
</style>
</head>
<body>
<h3>Route Coverage Logger</h3>
<p>Records GPS samples to IndexedDB. Detects gaps (GPS silence / timer drift) and writes <code>suspend_gap</code> records.</p>

<button id="start">Start</button>
<button id="stop" disabled>Stop</button>
<button id="export" disabled>Export JSON</button>
<button id="clear" >Clear DB</button>
<pre id="status">idle</pre>

<div id="mapwrap">
  <canvas id="map" aria-label="Live RTT-coloured route"></canvas>
</div>

<script>
// --- CONFIG ---
const DB_NAME = 'route_coverage_db_v1';
const STORE = 'samples';
const PING_URL = './ping.txt'; // same-origin tiny asset for latency checks
const GPS_MIN_INTERVAL_MS = 1000;   // how often we expect GPS callbacks (approx)
const GPS_SILENCE_THRESHOLD_MS = 15000; // if no GPS for this long => write suspend_gap
const TIMER_INTERVAL_MS = 5000;     // main heartbeat interval
const TIMER_DRIFT_THRESHOLD_MS = 1000 + TIMER_INTERVAL_MS; // gap over this => suspend_gap
const BATCH_FLUSH_MS = 5000;        // flush batch to IDB every N ms
const RTT_REF_MIN_MS = 50;          // baseline lower bound for color scaling
const RTT_REF_MAX_MS = 1500;        // baseline upper bound for color scaling
// ----------------

// --- IndexedDB wrapper ---
function openDB(){
  return new Promise((res, rej) => {
    const r = indexedDB.open(DB_NAME, 1);
    r.onupgradeneeded = e => {
      const db = e.target.result;
      if(!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
      }
    };
    r.onsuccess = e => res(e.target.result);
    r.onerror = e => rej(e.target.error);
  });
}

async function addItems(items){
  if(!items || items.length===0) return;
  const db = await openDB();
  const tx = db.transaction(STORE, 'readwrite');
  const s = tx.objectStore(STORE);
  for(const it of items) s.add(it);
  return new Promise((res, rej)=>{
    tx.oncomplete = () => res();
    tx.onerror = e => rej(e.target.error);
  });
}

async function exportAll(){
  const db = await openDB();
  const tx = db.transaction(STORE,'readonly');
  const s = tx.objectStore(STORE);
  const all = [];
  return new Promise((res, rej) => {
    s.openCursor().onsuccess = e => {
      const c = e.target.result;
      if(!c) return res(all);
      all.push(c.value);
      c.continue();
    };
    tx.onerror = e => rej(e.target.error);
  });
}

async function clearDB(){
  const db = await openDB();
  const tx = db.transaction(STORE,'readwrite');
  const s = tx.objectStore(STORE);
  s.clear();
  return new Promise((res, rej) => {
    tx.oncomplete = () => res();
    tx.onerror = e => rej(e.target.error);
  });
}

// --- state & batch buffer ---
let latestPos = null;
let lastGpsTs = 0;       // Date.now() when last GPS callback arrived
let lastTickPerf = performance.now();
let lastTickWall = Date.now();
let running = false;
let watchId = null;
let timer = null;
let batch = [];
let lastFlush = Date.now();
const mapPoints = [];
const mapCanvas = document.getElementById('map');
const mapCtx = mapCanvas.getContext('2d');

// helper to push sample to batch
function pushSample(obj){
  obj.created_at = new Date().toISOString();
  batch.push(obj);
  // enable export button
  document.getElementById('export').disabled = false;
}

// flush batch periodically
async function flushIfNeeded(force=false){
  const now = Date.now();
  if(batch.length === 0) return;
  if(force || now - lastFlush >= BATCH_FLUSH_MS) {
    const toWrite = batch.splice(0, batch.length);
    try {
      await addItems(toWrite);
      lastFlush = Date.now();
      status(`Flushed ${toWrite.length} samples`);
    } catch(e){
      console.error('DB write error', e);
      status('DB write error: ' + e);
    }
  }
}

// --- GPS handling (method 3) ---
function startGPS(){
  if(!('geolocation' in navigator)) {
    status('Geolocation not supported');
    return;
  }
  // prefer high accuracy for route mapping
  watchId = navigator.geolocation.watchPosition(
    p => {
      latestPos = p;
      lastGpsTs = Date.now();
      // sample object
      const s = {
        type: 'gps',
        ts: new Date().toISOString(),
        lat: p.coords.latitude,
        lon: p.coords.longitude,
        accuracy_m: p.coords.accuracy,
        altitude_m: p.coords.altitude,
        speed_m_s: p.coords.speed,
        heading_deg: p.coords.heading
      };
      pushSample(s);
      // flush if necessary
      flushIfNeeded();
    },
    err => {
      console.warn('geo error', err);
      pushSample({ type:'gps_error', ts:new Date().toISOString(), error: String(err.code) + ':' + err.message });
    },
    { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 }
  );
  status('GPS started');
}

function stopGPS(){
  if(watchId!=null) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
  latestPos = null;
  status('GPS stopped');
}

// --- Optional ping (simple RTT) ---
async function pingOnce(){
  if(!PING_URL) return null;
  const t0 = performance.now();
  const t0ws = Date.now();
  const cacheBust = `${PING_URL}${PING_URL.includes('?') ? '&' : '?'}_cb=${Math.random()*1e9|0}`;
  try {
    const r = await fetch(cacheBust, {method:'GET', cache:'no-store'});
    const t1 = performance.now();
    const rec = {
      type: 'ping',
      ok: r.ok,
      status: r.status,
      rtt_ms: Math.round(t1 - t0),
      ts: new Date(t0ws).toISOString()
    };
    if(navigator.connection) {
      rec.effective_type = navigator.connection.effectiveType;
      rec.downlink_mbps = navigator.connection.downlink;
    }
    return rec;
  } catch(e){
    const t1 = performance.now();
    const rec = {
      type: 'ping',
      ok: false,
      status: null,
      rtt_ms: Math.round(t1 - t0),
      ts: new Date(t0ws).toISOString(),
      err: String(e)
    };
    if(navigator.connection) {
      rec.effective_type = navigator.connection.effectiveType;
      rec.downlink_mbps = navigator.connection.downlink;
    }
    return rec;
  }
}

// --- suspension detection logic ---
// method 3: detect GPS silence
function checkForGaps(){
  const now = Date.now();
  // 1) GPS silence detection (method 3)
  const gpsGap = now - lastGpsTs;
  if(lastGpsTs > 0 && gpsGap > GPS_SILENCE_THRESHOLD_MS) {
    // write a suspend_gap record
    const gapRec = {
      type: 'suspend_gap',
      method: 'gps_silence',
      detected_at: new Date().toISOString(),
      gap_ms: gpsGap,
      last_gps_at: new Date(lastGpsTs).toISOString(),
      approx_resume_noted: null,
      note: `No GPS callback for ${gpsGap} ms`
    };
    pushSample(gapRec);
    status(`GPS silence gap detected ${Math.round(gpsGap/1000)}s`);
    // after logging once, reset lastGpsTs to now so we don't spam
    lastGpsTs = now;
  }

  // 2) Timer drift detection (secondary)
  const nowPerf = performance.now();
  const gapPerf = nowPerf - lastTickPerf;
  lastTickPerf = nowPerf;
  if(gapPerf > TIMER_DRIFT_THRESHOLD_MS) {
    const gapRec = {
      type: 'suspend_gap',
      method: 'timer_drift',
      detected_at: new Date().toISOString(),
      gap_ms: Math.round(gapPerf),
      note: `Timer gap of ${Math.round(gapPerf)} ms (expected ${TIMER_INTERVAL_MS} ms)`
    };
    pushSample(gapRec);
    status(`Timer drift gap detected ${Math.round(gapPerf/1000)}s`);
  }

  // 3) Wall-clock drift (helps if performance.now() is frozen during suspend)
  const gapWall = now - lastTickWall;
  lastTickWall = now;
  if(gapWall > TIMER_DRIFT_THRESHOLD_MS) {
    const gapRec = {
      type: 'suspend_gap',
      method: 'wall_clock',
      detected_at: new Date().toISOString(),
      gap_ms: gapWall,
      note: `Wall clock gap of ${gapWall} ms (expected ${TIMER_INTERVAL_MS} ms)`
    };
    pushSample(gapRec);
    status(`Wall clock gap detected ${Math.round(gapWall/1000)}s`);
  }
}

// --- heartbeat tick ---
async function tick(){
  if(!running) return;
  // optional ping
  if(PING_URL) {
    const r = await pingOnce();
    if(r){
      // attach last known GPS if any
      if(latestPos) {
        r.lat = latestPos.coords.latitude;
        r.lon = latestPos.coords.longitude;
      }
      pushSample(r);
      recordMapPoint(r);
    }
  }
  // check for gaps (GPS silence + timer drift)
  checkForGaps();
  // flush small batches occasionally
  await flushIfNeeded();
}

// --- UI helpers ---
function status(s){
  document.getElementById('status').textContent = s;
}

function recordConnectivity(state){
  const rec = {
    type: 'connectivity',
    ts: new Date().toISOString(),
    state,
    navigator_online: navigator.onLine
  };
  if(navigator.connection) {
    rec.effective_type = navigator.connection.effectiveType;
    rec.downlink_mbps = navigator.connection.downlink;
  }
  pushSample(rec);
}

function rttBounds(){
  if(mapPoints.length === 0) return [RTT_REF_MIN_MS, RTT_REF_MAX_MS];
  let mn = Infinity;
  let mx = -Infinity;
  for(const p of mapPoints){
    if(p.rtt_ms==null || isNaN(p.rtt_ms)) continue;
    mn = Math.min(mn, p.rtt_ms);
    mx = Math.max(mx, p.rtt_ms);
  }
  if(!isFinite(mn)) mn = RTT_REF_MIN_MS;
  if(!isFinite(mx)) mx = RTT_REF_MAX_MS;
  mn = Math.min(mn, RTT_REF_MIN_MS);
  mx = Math.max(mx, RTT_REF_MAX_MS);
  if(mx === mn) mx = mn + 1;
  return [mn, mx];
}

function rttToColor(rtt, bounds){
  if(rtt==null || isNaN(rtt)) return '#666';
  const [mn, mx] = bounds || rttBounds();
  const t = Math.max(0, Math.min(1, (rtt - mn) / (mx - mn)));
  const hue = 120 * (1 - t); // green -> red as RTT increases
  return `hsl(${hue}, 85%, 45%)`;
}

function latLonBounds(){
  if(mapPoints.length === 0) return null;
  let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
  for(const p of mapPoints){
    minLat = Math.min(minLat, p.lat);
    maxLat = Math.max(maxLat, p.lat);
    minLon = Math.min(minLon, p.lon);
    maxLon = Math.max(maxLon, p.lon);
  }
  const spanLat = Math.max(maxLat - minLat, 1e-6);
  const spanLon = Math.max(maxLon - minLon, 1e-6);
  return { minLat, maxLat, minLon, maxLon, spanLat, spanLon };
}

function drawMap(){
  if(!mapCanvas || !mapCtx) return;
  const dpr = window.devicePixelRatio || 1;
  const cw = mapCanvas.clientWidth || mapCanvas.width;
  const ch = mapCanvas.clientHeight || mapCanvas.height || 320;
  mapCanvas.width = cw * dpr;
  mapCanvas.height = ch * dpr;
  mapCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  mapCtx.clearRect(0, 0, cw, ch);
  if(mapPoints.length === 0) return;

  const pad = 12;
  const usableW = Math.max(cw - pad * 2, 10);
  const usableH = Math.max(ch - pad * 2, 10);
  const bounds = latLonBounds();
  if(!bounds) return;
  const rttScale = rttBounds();

  const project = p => {
    const xRatio = (p.lon - bounds.minLon) / bounds.spanLon;
    const yRatio = (p.lat - bounds.minLat) / bounds.spanLat;
    return {
      x: pad + xRatio * usableW,
      y: pad + (1 - yRatio) * usableH
    };
  };

  mapCtx.lineWidth = 3;
  mapCtx.lineJoin = 'round';
  mapCtx.lineCap = 'round';

  for(let i=1;i<mapPoints.length;i++){
    const a = mapPoints[i-1];
    const b = mapPoints[i];
    const pa = project(a);
    const pb = project(b);
    mapCtx.strokeStyle = rttToColor(b.rtt_ms, rttScale);
    mapCtx.beginPath();
    mapCtx.moveTo(pa.x, pa.y);
    mapCtx.lineTo(pb.x, pb.y);
    mapCtx.stroke();
  }

  const last = mapPoints[mapPoints.length-1];
  const pl = project(last);
  mapCtx.fillStyle = rttToColor(last.rtt_ms, rttScale);
  mapCtx.beginPath();
  mapCtx.arc(pl.x, pl.y, 4, 0, Math.PI*2);
  mapCtx.fill();
}

function recordMapPoint(sample){
  if(!sample || sample.type !== 'ping') return;
  if(typeof sample.lat !== 'number' || typeof sample.lon !== 'number') return;
  mapPoints.push({ lat: sample.lat, lon: sample.lon, rtt_ms: sample.rtt_ms });
  drawMap();
}

// --- start/stop controls ---
document.getElementById('start').addEventListener('click', async ()=>{
  if(running) return;
  running = true;
  document.getElementById('start').disabled = true;
  document.getElementById('stop').disabled = false;
  document.getElementById('export').disabled = true;
  // reset markers
  lastGpsTs = 0;
  lastTickPerf = performance.now();
  lastTickWall = Date.now();
  recordConnectivity(navigator.onLine ? 'online' : 'offline');
  // start gps & heartbeat
  startGPS();
  // immediate tick then interval
  tick();
  timer = setInterval(tick, TIMER_INTERVAL_MS);
  status('Running â€” logging');
});

document.getElementById('stop').addEventListener('click', async ()=>{
  if(!running) return;
  running = false;
  document.getElementById('start').disabled = false;
  document.getElementById('stop').disabled = true;
  clearInterval(timer);
  timer = null;
  stopGPS();
  // final flush
  await flushIfNeeded(true);
  // write a stop marker
  pushSample({ type:'session_stop', ts:new Date().toISOString() });
  await flushIfNeeded(true);
  status('Stopped and flushed');
});

document.getElementById('export').addEventListener('click', async ()=>{
  try {
    await flushIfNeeded(true);
    const all = await exportAll();
    const blob = new Blob([JSON.stringify(all,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'route_coverage_export.json';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    status(`Exported ${all.length} records`);
  } catch(e){
    status('Export error: ' + e);
  }
});

document.getElementById('clear').addEventListener('click', async ()=>{
  if(!confirm('Clear all stored samples?')) return;
  await clearDB();
  document.getElementById('export').disabled = true;
  status('DB cleared');
});

// --- visibility hint: mark page hidden/visible ---
document.addEventListener('visibilitychange', () => {
  if(document.hidden) {
    pushSample({ type:'visibility', ts:new Date().toISOString(), state:'hidden' });
    flushIfNeeded(true);
  } else {
    pushSample({ type:'visibility', ts:new Date().toISOString(), state:'visible' });
  }
});

// --- online/offline markers ---
window.addEventListener('online', () => {
  recordConnectivity('online');
  flushIfNeeded(true);
});

window.addEventListener('offline', () => {
  recordConnectivity('offline');
  flushIfNeeded(true);
});

// ensure flush on page unload
window.addEventListener('pagehide', async () => {
  await flushIfNeeded(true);
});

// redraw map on resize
window.addEventListener('resize', drawMap);
drawMap();

// end of script
</script>
</body>
</html>
